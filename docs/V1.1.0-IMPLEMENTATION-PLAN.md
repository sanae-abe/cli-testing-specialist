# v1.1.0 Implementation Plan

**Version**: 1.1.0
**Estimated Duration**: 4 weeks
**Start Date**: TBD
**Status**: Planning

---

## üìã Task Breakdown

### Phase 1: Core Modes Implementation (Week 1-2)

**Estimated**: 10-15 hours

#### Task 1.1: `--ci-mode` Flag (4-5 hours)

**Files to Modify**:
- `src/cli/commands.rs`: Add `ci_mode: bool` field to `RunCommand`
- `src/runner/bats_executor.rs`: Add `run_with_ci_mode()` method
- `src/main.rs`: Route to CI mode when flag is set

**Implementation Steps**:
1. Add CLI flag with clap
   ```rust
   /// CI integration mode: security-focused, informational, always exit 0
   #[arg(long, conflicts_with = "strict")]
   pub ci_mode: bool,
   ```

2. Filter test categories
   ```rust
   let ci_categories = vec![
       TestCategory::Security,
       TestCategory::InputValidation,
   ];
   ```

3. Modify executor behavior
   ```rust
   pub fn run_with_ci_mode(&self, test_dir: &Path) -> Result<TestReport> {
       // Relaxed timeout: 600s
       // Always return Ok() with full report
       // Classify findings by severity
   }
   ```

4. Unit tests (6 test cases)
   - CI mode filters to security categories
   - Always exits 0
   - Generates correct report format

**Acceptance Criteria**:
- [ ] `--ci-mode` flag exists and conflicts with `--strict`
- [ ] Only security + input-validation tests run
- [ ] Exit code is always 0
- [ ] Report includes severity classification
- [ ] 6/6 unit tests pass

---

#### Task 1.2: `--informational` Flag (3-4 hours)

**Files to Modify**:
- `src/cli/commands.rs`: Add `informational: bool` field
- `src/runner/bats_executor.rs`: Add `run_with_informational()` method
- `src/reporter/markdown.rs`: Adjust terminology (Findings vs Failures)

**Implementation Steps**:
1. Add CLI flag
   ```rust
   /// Informational mode: run all tests, report findings, always exit 0
   #[arg(long, conflicts_with = "ci_mode")]
   pub informational: bool,
   ```

2. Run all categories with relaxed reporting
   ```rust
   pub fn run_with_informational(&self, test_dir: &Path) -> Result<TestReport> {
       // All categories
       // Always return Ok()
       // Report emphasizes "insights" not "failures"
   }
   ```

3. Adjust report formatting
   ```markdown
   ## üìä Test Findings (Informational Mode)

   This report is for informational purposes only.
   Findings do not indicate failures.
   ```

4. Unit tests (4 test cases)
   - All categories run
   - Always exits 0
   - Report uses "Findings" terminology

**Acceptance Criteria**:
- [ ] `--informational` flag exists
- [ ] All test categories run
- [ ] Exit code is always 0
- [ ] Report uses informational language
- [ ] 4/4 unit tests pass

---

#### Task 1.3: `--security-only` Flag (3-4 hours)

**Files to Modify**:
- `src/cli/commands.rs`: Add `security_only: bool` field
- `src/runner/bats_executor.rs`: Add `run_security_only()` method
- `src/main.rs`: Special exit code 2 handling

**Implementation Steps**:
1. Add CLI flag
   ```rust
   /// Security-only mode: run security tests, exit 2 on failure
   #[arg(long, conflicts_with_all = ["ci_mode", "informational"])]
   pub security_only: bool,
   ```

2. Filter and execute
   ```rust
   pub fn run_security_only(&self, test_dir: &Path) -> Result<TestReport> {
       // Categories: Security, InputValidation
       // Timeout: 600s (double normal)
       // Return Err() on security failure
   }
   ```

3. Exit code handling
   ```rust
   // src/main.rs
   if security_only {
       if report.has_security_failures() {
           std::process::exit(2);  // Security failure
       }
   }
   ```

4. Unit tests (5 test cases)
   - Only security categories run
   - Exit 0 on pass, 2 on security fail
   - Timeout is 600s

**Acceptance Criteria**:
- [ ] `--security-only` flag exists
- [ ] Only security tests run
- [ ] Exit code 0 on pass, 2 on fail
- [ ] Timeout is 600s
- [ ] 5/5 unit tests pass

---

### Phase 2: Configuration Detection (Week 3)

**Estimated**: 8-10 hours

#### Task 2.1: ConfigDetector Implementation (4-5 hours)

**New Files**:
- `src/analyzer/config_detector.rs`
- `tests/analyzer/config_detector_tests.rs`

**Implementation**:
```rust
pub struct ConfigDetector {
    pub patterns: Vec<ConfigPattern>,
}

pub struct ConfigPattern {
    pub regex: Regex,
    pub format: FileFormat,
    pub confidence: f32,
}

pub struct ConfigRequirement {
    pub option_name: String,        // "--config"
    pub expected_format: FileFormat, // TOML, YAML, JSON
    pub template: Option<String>,
    pub confidence: f32,
}

impl ConfigDetector {
    pub fn new() -> Self {
        // Precompiled regex patterns
        Self {
            patterns: vec![
                ConfigPattern {
                    regex: Regex::new(r"--config\s+<(\w+)>").unwrap(),
                    format: FileFormat::Unknown,
                    confidence: 0.8,
                },
                // ... more patterns
            ],
        }
    }

    pub fn detect_from_help(&self, help_output: &str) -> Vec<ConfigRequirement> {
        // Apply regex patterns
        // Infer format from option name or description
        // Generate template if format known
    }

    pub fn generate_template(&self, format: FileFormat) -> String {
        match format {
            FileFormat::TOML => "# TODO: Fill in your configuration\n[settings]\n",
            FileFormat::YAML => "# TODO: Fill in your configuration\nsettings:\n",
            FileFormat::JSON => "{\n  \"settings\": {}\n}\n",
            _ => "# Unknown format\n",
        }
    }
}
```

**Unit Tests** (8 test cases):
- Detects `--config <FILE>`
- Detects `-c, --config-file <PATH>`
- Infers TOML from `.toml` mention
- Generates valid TOML template
- Handles multiple config options
- Returns empty vec when no config found

**Acceptance Criteria**:
- [ ] Detects config options with 80%+ accuracy
- [ ] Generates valid templates for TOML/YAML/JSON
- [ ] 8/8 unit tests pass

---

#### Task 2.2: `--detect-config` Flag (2-3 hours)

**Files to Modify**:
- `src/cli/commands.rs`: Add flag to `AnalyzeCommand`
- `src/analyzer/cli_parser.rs`: Integrate `ConfigDetector`
- `src/types/analysis.rs`: Add `config_requirements` field

**Implementation**:
```rust
// CLI flag
#[arg(long)]
pub detect_config: bool,

// Integration
if self.detect_config {
    let detector = ConfigDetector::new();
    analysis.config_requirements = detector.detect_from_help(&help_output);
}
```

**Acceptance Criteria**:
- [ ] `--detect-config` flag works
- [ ] Requirements saved to analysis JSON
- [ ] 3/3 integration tests pass

---

#### Task 2.3: Documentation & Examples (2 hours)

**New Files**:
- `docs/CI-INTEGRATION.md`
- `examples/config-templates/`

**Content**:
- CI workflow examples
- Config template usage
- cmdrun, cldev specific guides

**Acceptance Criteria**:
- [ ] CI integration guide complete
- [ ] Template examples for TOML/YAML/JSON
- [ ] Example workflows for GitHub Actions, GitLab CI

---

### Phase 3: UI Detection (Week 4)

**Estimated**: 6-8 hours

#### Task 3.1: UiDetector Implementation (3-4 hours)

**New Files**:
- `src/analyzer/ui_detector.rs`
- `tests/analyzer/ui_detector_tests.rs`

**Implementation**:
```rust
pub struct UiDetector;

pub struct UiDependency {
    pub name: String,
    pub version: String,
    pub ecosystem: Ecosystem, // Rust, Node
    pub workarounds: Vec<Workaround>,
}

pub struct Workaround {
    pub method: WorkaroundMethod, // EnvVar, Flag, Config
    pub value: String,
    pub confidence: f32,
}

impl UiDetector {
    pub fn detect_rust_deps(cargo_toml: &Path) -> Vec<UiDependency> {
        // Parse Cargo.toml
        // Check for dialoguer, inquire, console, rustyline
        // Suggest workarounds based on library
    }

    pub fn detect_node_deps(package_json: &Path) -> Vec<UiDependency> {
        // Parse package.json
        // Check for prompts, inquirer, enquirer
        // Suggest workarounds
    }
}
```

**Unit Tests** (6 test cases):
- Detects dialoguer in Cargo.toml
- Suggests CI=true workaround
- Detects inquirer in package.json
- Handles missing files gracefully

**Acceptance Criteria**:
- [ ] Detects Rust UI libraries (dialoguer, inquire)
- [ ] Detects Node UI libraries (prompts, inquirer)
- [ ] Suggests valid workarounds with confidence scores
- [ ] 6/6 unit tests pass

---

#### Task 3.2: Integration & Reporting (2-3 hours)

**Files to Modify**:
- `src/cli/commands.rs`: Add `--detect-ui` flag
- `src/analyzer/cli_parser.rs`: Integrate `UiDetector`
- `src/reporter/markdown.rs`: Add UI warnings section

**Report Output**:
```markdown
## ‚ö†Ô∏è Interactive UI Detected

This tool uses `dialoguer v0.10.0` which may hang in CI environments.

**Recommended workarounds** (sorted by confidence):
1. **Environment Variable** (90% confidence): Set `CI=true`
2. **Flag** (60% confidence): Try `--non-interactive` if available
3. **Config File** (40% confidence): Create config with `interactive: false`

**Quick test**:
```bash
CI=true ./your-tool --help
```

If this hangs, the tool may not respect CI environment variable.
```

**Acceptance Criteria**:
- [ ] `--detect-ui` flag works
- [ ] Warnings appear in Markdown report
- [ ] Workarounds sorted by confidence
- [ ] 2/2 integration tests pass

---

#### Task 3.3: Documentation (1 hour)

**New Files**:
- `docs/INTERACTIVE-UI-WORKAROUNDS.md`

**Content**:
- Common UI libraries and their workarounds
- CI environment variable reference
- Examples for dialoguer, inquire, prompts

**Acceptance Criteria**:
- [ ] Comprehensive workaround guide
- [ ] Examples for 5+ UI libraries

---

## üß™ Testing Strategy

### Unit Tests

**Total**: 29 test cases

- Phase 1: 15 tests (ci-mode, informational, security-only)
- Phase 2: 8 tests (config detection)
- Phase 3: 6 tests (UI detection)

**Coverage Target**: 90%+

### Integration Tests

**Total**: 12 integration tests

- Real tools: curl, cmdrun, cldev, package-publisher
- Each mode tested with real BATS execution
- Exit code verification
- Report format validation

### Manual Testing

**Test Matrix**:
| Tool | `--ci-mode` | `--informational` | `--security-only` | `--detect-config` | `--detect-ui` |
|------|-------------|-------------------|-------------------|-------------------|---------------|
| curl | ‚úÖ | ‚úÖ | ‚úÖ | N/A | N/A |
| cmdrun | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | N/A |
| cldev | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | N/A |
| package-publisher | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ (dialoguer) |

---

## üìä Progress Tracking

### Week 1-2: Core Modes
- [ ] Task 1.1: `--ci-mode` (4-5h)
- [ ] Task 1.2: `--informational` (3-4h)
- [ ] Task 1.3: `--security-only` (3-4h)
- [ ] Integration tests (2h)

### Week 3: Config Detection
- [ ] Task 2.1: ConfigDetector (4-5h)
- [ ] Task 2.2: `--detect-config` (2-3h)
- [ ] Task 2.3: Documentation (2h)

### Week 4: UI Detection
- [ ] Task 3.1: UiDetector (3-4h)
- [ ] Task 3.2: Integration (2-3h)
- [ ] Task 3.3: Documentation (1h)

### Final Week: Polish
- [ ] End-to-end testing (4h)
- [ ] Documentation review (2h)
- [ ] Release preparation (2h)

---

## üöÄ Release Checklist

- [ ] All 29 unit tests pass
- [ ] All 12 integration tests pass
- [ ] Manual testing complete (4 tools √ó 5 flags)
- [ ] Documentation complete
  - [ ] V1.1.0-DESIGN.md
  - [ ] CI-INTEGRATION.md
  - [ ] INTERACTIVE-UI-WORKAROUNDS.md
- [ ] CHANGELOG.md updated
- [ ] Version bumped to 1.1.0
- [ ] Git tag v1.1.0 created
- [ ] Release pushed to GitHub

---

## üí° Implementation Notes

### Performance Considerations

- Config detection: Parse help output once, cache results
- UI detection: Only parse Cargo.toml/package.json once
- Regex compilation: Precompile patterns in detector constructors

### Error Handling

- Config detection failures should not block analysis
- UI detection failures should warn but not error
- Mode flags should validate mutual exclusivity at CLI level

### Backward Compatibility

- All new features are opt-in flags
- Existing behavior unchanged when no flags used
- Exit codes unchanged in normal mode

---

**Last Updated**: 2025-11-12
**Status**: Ready for implementation
**Next Step**: Begin Phase 1, Task 1.1 (`--ci-mode`)
