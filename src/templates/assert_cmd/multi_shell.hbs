// Auto-generated tests for {{cli_name}} - MultiShell Category
// Generated by cli-testing-specialist v1.1.0
//
// Note: assert_cmd tests run in Rust's test framework, not directly in shells.
// These tests verify shell-independent behavior and POSIX compliance.

use assert_cmd::Command;
use predicates::prelude::*;

/// Test: Exit code 0 for successful operation
#[test]
fn test_success_exit_code() {
    let mut cmd = Command::cargo_bin("{{cli_name}}").unwrap();
    cmd.arg("--help")
        .assert()
        .code(0);
}

/// Test: Non-zero exit code for errors
#[test]
fn test_error_exit_code() {
    let mut cmd = Command::cargo_bin("{{cli_name}}").unwrap();
    cmd.arg("--invalid-option-xyz")
        .assert()
        .code(predicate::ne(0));
}

/// Test: Output to stdout (not stderr) for normal messages
#[test]
fn test_stdout_for_normal_output() {
    let mut cmd = Command::cargo_bin("{{cli_name}}").unwrap();
    cmd.arg("--help")
        .assert()
        .success()
        .stdout(predicate::str::is_empty().not());
}

/// Test: Output to stderr for error messages
#[test]
fn test_stderr_for_errors() {
    let mut cmd = Command::cargo_bin("{{cli_name}}").unwrap();
    cmd.arg("--invalid-option-xyz")
        .assert()
        .failure()
        .stderr(predicate::str::is_empty().not());
}

/// Test: Handle environment variables
#[test]
fn test_environment_variable_handling() {
    let mut cmd = Command::cargo_bin("{{cli_name}}").unwrap();
    cmd.env("TEST_VAR", "test_value")
        .assert();
    // Behavior depends on whether CLI uses environment variables
}

/// Test: Handle stdin input
#[test]
fn test_stdin_handling() {
    let mut cmd = Command::cargo_bin("{{cli_name}}").unwrap();
    cmd.write_stdin("test input\n")
        .assert();
    // Behavior depends on whether CLI reads from stdin
}

/// Test: Arguments with equals sign (--option=value)
#[test]
fn test_option_equals_syntax() {
    let mut cmd = Command::cargo_bin("{{cli_name}}").unwrap();
    cmd.arg("--option=value")
        .assert();
    // Should handle both --option=value and --option value
}

/// Test: Combined short options (-abc equivalent to -a -b -c)
#[test]
fn test_combined_short_options() {
    let mut cmd = Command::cargo_bin("{{cli_name}}").unwrap();
    cmd.arg("-abc")
        .assert();
    // POSIX-compliant CLIs should support combined short options
}

/// Test: Double dash terminates option parsing (-- file)
#[test]
fn test_double_dash_terminator() {
    let mut cmd = Command::cargo_bin("{{cli_name}}").unwrap();
    cmd.arg("--")
        .arg("--not-an-option")
        .assert();
    // Arguments after -- should be treated as positional, not options
}

/// Test: No shell-specific characters in output
#[test]
fn test_output_shell_safety() {
    let mut cmd = Command::cargo_bin("{{cli_name}}").unwrap();
    cmd.arg("--help")
        .assert()
        .success()
        .stdout(predicate::str::contains("$").not())
        .stdout(predicate::str::contains("`").not());
    // Output should not contain unescaped shell metacharacters
}
